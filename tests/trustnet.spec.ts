import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, LAMPORTS_PER_SOL, PublicKey } from "@solana/web3.js";
import { assert, expect } from "chai";
import crypto from "crypto";

// Load IDL (generated by anchor build)
import { Trustnet } from "../target/types/trustnet";

const SOL = LAMPORTS_PER_SOL;

function randomBytes(n: number): number[] {
  return Array.from(crypto.randomBytes(n));
}

function sha256(data: string): number[] {
  return Array.from(crypto.createHash("sha256").update(data).digest());
}

describe("trustnet", () => {
  const provider = anchor.AnchorProvider.local();
  anchor.setProvider(provider);

  const program = anchor.workspace.Trustnet as Program<Trustnet>;

  // Test keypairs
  let client: Keypair;
  let providerKp: Keypair; // 'provider' is reserved

  // PDAs
  const findJobPda = (jobId: number[]) =>
    PublicKey.findProgramAddressSync([Buffer.from("job"), Buffer.from(jobId)], program.programId);
  const findJobVaultPda = (job: PublicKey) =>
    PublicKey.findProgramAddressSync([Buffer.from("job_vault"), job.toBuffer()], program.programId);
  const findTreasuryPda = () =>
    PublicKey.findProgramAddressSync([Buffer.from("treasury")], program.programId);
  const findReputationPda = (agent: PublicKey) =>
    PublicKey.findProgramAddressSync([Buffer.from("reputation"), agent.toBuffer()], program.programId);
  const findRepVaultPda = (agent: PublicKey) =>
    PublicKey.findProgramAddressSync([Buffer.from("rep_vault"), agent.toBuffer()], program.programId);

  beforeEach(async () => {
    client = Keypair.generate();
    providerKp = Keypair.generate();

    // Fund test accounts
    const sig1 = await provider.connection.requestAirdrop(client.publicKey, 5 * SOL);
    const sig2 = await provider.connection.requestAirdrop(providerKp.publicKey, 5 * SOL);
    await provider.connection.confirmTransaction(sig1);
    await provider.connection.confirmTransaction(sig2);
  });

  describe("reputation", () => {
    it("initializes reputation with stake", async () => {
      const [reputation] = findReputationPda(client.publicKey);
      const [repVault] = findRepVaultPda(client.publicKey);
      const stakeLamports = new anchor.BN(0.1 * SOL);

      await program.methods
        .initReputation(stakeLamports, [])
        .accounts({
          agent: client.publicKey,
          reputation,
          repVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      const repAccount = await program.account.agentReputation.fetch(reputation);
      assert.equal(repAccount.agent.toBase58(), client.publicKey.toBase58());
      assert.equal(repAccount.totalJobsCompleted.toNumber(), 0);
      assert.equal(repAccount.stakeAmount.toNumber(), stakeLamports.toNumber());
    });

    it("fails to init reputation below minimum stake", async () => {
      const [reputation] = findReputationPda(client.publicKey);
      const [repVault] = findRepVaultPda(client.publicKey);
      const tooLowStake = new anchor.BN(0.01 * SOL); // Below 0.1 SOL minimum

      try {
        await program.methods
          .initReputation(tooLowStake, [])
          .accounts({
            agent: client.publicKey,
            reputation,
            repVault,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([client])
          .rpc();
        assert.fail("Expected error for insufficient stake");
      } catch (err: any) {
        expect(err.toString()).to.include("InsufficientStake");
      }
    });
  });

  describe("job lifecycle", () => {
    let jobId: number[];
    let job: PublicKey;
    let jobVault: PublicKey;
    let treasury: PublicKey;

    beforeEach(async () => {
      jobId = randomBytes(32);
      [job] = findJobPda(jobId);
      [jobVault] = findJobVaultPda(job);
      [treasury] = findTreasuryPda();

      // Init reputation for both parties
      const [clientRep] = findReputationPda(client.publicKey);
      const [clientRepVault] = findRepVaultPda(client.publicKey);
      const [providerRep] = findReputationPda(providerKp.publicKey);
      const [providerRepVault] = findRepVaultPda(providerKp.publicKey);

      await program.methods
        .initReputation(new anchor.BN(0.1 * SOL), [])
        .accounts({
          agent: client.publicKey,
          reputation: clientRep,
          repVault: clientRepVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      await program.methods
        .initReputation(new anchor.BN(0.1 * SOL), [])
        .accounts({
          agent: providerKp.publicKey,
          reputation: providerRep,
          repVault: providerRepVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([providerKp])
        .rpc();
    });

    it("creates a job with escrow", async () => {
      const amount = new anchor.BN(0.5 * SOL);
      const deadline = new anchor.BN(Math.floor(Date.now() / 1000) + 3600);

      await program.methods
        .createJob(jobId, amount, deadline, { clientApproval: {} }, Array(64).fill(0), sha256("terms"))
        .accounts({
          client: client.publicKey,
          provider: providerKp.publicKey,
          job,
          jobVault,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      const jobAccount = await program.account.jobEscrow.fetch(job);
      assert.equal(jobAccount.client.toBase58(), client.publicKey.toBase58());
      assert.equal(jobAccount.provider.toBase58(), providerKp.publicKey.toBase58());
      assert.equal(jobAccount.amount.toNumber(), amount.toNumber());
      expect(jobAccount.status).to.deep.equal({ created: {} });

      // Check vault received funds
      const vaultBalance = await provider.connection.getBalance(jobVault);
      assert.equal(vaultBalance, amount.toNumber());
    });

    it("completes happy path (create → accept → submit → approve)", async () => {
      const amount = new anchor.BN(0.5 * SOL);
      const deadline = new anchor.BN(Math.floor(Date.now() / 1000) + 3600);
      const providerStake = new anchor.BN(0.1 * SOL);

      // Create
      await program.methods
        .createJob(jobId, amount, deadline, { clientApproval: {} }, Array(64).fill(0), sha256("terms"))
        .accounts({
          client: client.publicKey,
          provider: providerKp.publicKey,
          job,
          jobVault,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      // Accept
      await program.methods
        .acceptJob(providerStake)
        .accounts({
          provider: providerKp.publicKey,
          job,
          jobVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([providerKp])
        .rpc();

      let jobAccount = await program.account.jobEscrow.fetch(job);
      expect(jobAccount.status).to.deep.equal({ active: {} });

      // Submit
      await program.methods
        .submitCompletion(sha256("submission"))
        .accounts({
          provider: providerKp.publicKey,
          job,
        })
        .signers([providerKp])
        .rpc();

      jobAccount = await program.account.jobEscrow.fetch(job);
      expect(jobAccount.status).to.deep.equal({ submitted: {} });

      // Record provider balance before approval
      const providerBalBefore = await provider.connection.getBalance(providerKp.publicKey);

      // Approve
      await program.methods
        .approveCompletion()
        .accounts({
          client: client.publicKey,
          job,
          jobVault,
          treasury,
          provider: providerKp.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      jobAccount = await program.account.jobEscrow.fetch(job);
      expect(jobAccount.status).to.deep.equal({ completed: {} });

      // Provider should have received payout
      const providerBalAfter = await provider.connection.getBalance(providerKp.publicKey);
      const expectedPayout = amount.toNumber() + providerStake.toNumber();
      const fee = Math.floor(amount.toNumber() * 10 / 10000); // 0.1% fee
      assert.approximately(providerBalAfter - providerBalBefore, expectedPayout - fee, 10000); // Allow for rounding
    });

    it("prevents non-client from approving", async () => {
      const amount = new anchor.BN(0.5 * SOL);
      const deadline = new anchor.BN(Math.floor(Date.now() / 1000) + 3600);

      // Create and accept
      await program.methods
        .createJob(jobId, amount, deadline, { clientApproval: {} }, Array(64).fill(0), sha256("terms"))
        .accounts({
          client: client.publicKey,
          provider: providerKp.publicKey,
          job,
          jobVault,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      await program.methods
        .acceptJob(new anchor.BN(0.1 * SOL))
        .accounts({
          provider: providerKp.publicKey,
          job,
          jobVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([providerKp])
        .rpc();

      await program.methods
        .submitCompletion(sha256("submission"))
        .accounts({
          provider: providerKp.publicKey,
          job,
        })
        .signers([providerKp])
        .rpc();

      // Provider tries to approve (should fail)
      try {
        await program.methods
          .approveCompletion()
          .accounts({
            client: providerKp.publicKey, // Wrong signer!
            job,
            jobVault,
            treasury,
            provider: providerKp.publicKey,
            systemProgram: anchor.web3.SystemProgram.programId,
          })
          .signers([providerKp])
          .rpc();
        assert.fail("Expected authorization error");
      } catch (err: any) {
        expect(err.toString()).to.include("Unauthorized");
      }
    });
  });

  describe("ratings", () => {
    it("allows client to rate provider after job completion", async () => {
      const jobId = randomBytes(32);
      const [job] = findJobPda(jobId);
      const [jobVault] = findJobVaultPda(job);
      const [treasury] = findTreasuryPda();
      const [providerRep] = findReputationPda(providerKp.publicKey);

      // Setup: init reputation
      const [clientRep] = findReputationPda(client.publicKey);
      const [clientRepVault] = findRepVaultPda(client.publicKey);
      const [providerRepVault] = findRepVaultPda(providerKp.publicKey);

      await program.methods
        .initReputation(new anchor.BN(0.1 * SOL), [])
        .accounts({
          agent: client.publicKey,
          reputation: clientRep,
          repVault: clientRepVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      await program.methods
        .initReputation(new anchor.BN(0.1 * SOL), [])
        .accounts({
          agent: providerKp.publicKey,
          reputation: providerRep,
          repVault: providerRepVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([providerKp])
        .rpc();

      // Complete a job
      await program.methods
        .createJob(
          jobId,
          new anchor.BN(0.5 * SOL),
          new anchor.BN(Math.floor(Date.now() / 1000) + 3600),
          { clientApproval: {} },
          Array(64).fill(0),
          sha256("terms")
        )
        .accounts({
          client: client.publicKey,
          provider: providerKp.publicKey,
          job,
          jobVault,
          treasury,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      await program.methods
        .acceptJob(new anchor.BN(0.1 * SOL))
        .accounts({
          provider: providerKp.publicKey,
          job,
          jobVault,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([providerKp])
        .rpc();

      await program.methods
        .submitCompletion(sha256("done"))
        .accounts({ provider: providerKp.publicKey, job })
        .signers([providerKp])
        .rpc();

      await program.methods
        .approveCompletion()
        .accounts({
          client: client.publicKey,
          job,
          jobVault,
          treasury,
          provider: providerKp.publicKey,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      // Rate
      const [rating] = PublicKey.findProgramAddressSync(
        [Buffer.from("rating"), Buffer.from(jobId), client.publicKey.toBuffer()],
        program.programId
      );

      await program.methods
        .rateJob(jobId, 5, [1, 2], sha256("great work"))
        .accounts({
          rater: client.publicKey,
          job,
          rateeReputation: providerRep,
          rating,
          systemProgram: anchor.web3.SystemProgram.programId,
        })
        .signers([client])
        .rpc();

      // Check reputation updated
      const repAccount = await program.account.agentReputation.fetch(providerRep);
      assert.equal(repAccount.ratingCount.toNumber(), 1);
      assert.equal(repAccount.avgRating, 500); // 5.00 * 100
    });
  });
});
